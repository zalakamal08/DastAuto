# pentester_project/pentester_graph.py
import pprint 
from langgraph.graph import StateGraph, END
from langgraph.graph.state import CompiledStateGraph
from typing import Optional, List, Any 
import dataclasses 

from state import PentestState, HttpRequest, HttpResponse, VulnerabilityType, AnalysisVerdict, AttemptDetail
from graph_nodes import (
    capture_baseline_node,
    generate_strategy_and_payload_node, 
    inject_and_execute_node,
    dynamic_analyze_response_node,
    generate_executive_summary_node, 
    generate_dynamic_report_node,    
    should_continue_dynamic_testing # This function IS the decision logic
)

class AutomatedPentesterGraph:
    def __init__(self):
        self.graph = self._build_graph()
    def _build_graph(self) -> CompiledStateGraph:
        workflow = StateGraph(PentestState)

        workflow.add_node("capture_baseline", capture_baseline_node)
        workflow.add_node("generate_strategy_and_payload_batch", generate_strategy_and_payload_node) 
        workflow.add_node("inject_and_execute", inject_and_execute_node)
        workflow.add_node("dynamic_analyze_response", dynamic_analyze_response_node)
        
        # should_continue_dynamic_testing is now a regular node that updates 'next_edge' in state
        workflow.add_node("decision_node", should_continue_dynamic_testing) 

        workflow.add_node("generate_executive_summary", generate_executive_summary_node) 
        workflow.add_node("assemble_final_report", generate_dynamic_report_node) 

        workflow.set_entry_point("capture_baseline")
        workflow.add_edge("capture_baseline", "generate_strategy_and_payload_batch")
        workflow.add_edge("generate_strategy_and_payload_batch", "inject_and_execute") 
        workflow.add_edge("inject_and_execute", "dynamic_analyze_response")
        workflow.add_edge("dynamic_analyze_response", "decision_node") # Explicitly go to the decision node
        
        # Conditional edges now branch from "decision_node"
        # The condition function reads the 'next_edge' field from the state
        workflow.add_conditional_edges(
            "decision_node", # The node that has set state.next_edge
            lambda state: state.next_edge, # This lambda reads the decision from the state
            {
                "next_payload_in_batch_edge": "inject_and_execute", 
                "continue_testing_edge": "generate_strategy_and_payload_batch", 
                "generate_report_edge": "generate_executive_summary" 
            }
        )
        
        workflow.add_edge("generate_executive_summary", "assemble_final_report") 
        workflow.add_edge("assemble_final_report", END)
        
        return workflow.compile()
    # ... run_test method remains the same as the last complete version ...
    async def run_test(
        self,
        target_request: HttpRequest,
        vulnerability_type: VulnerabilityType,
        target_parameter: str,
        max_total_attempts: int = 15 
    ) -> PentestState:
        # Explicitly create the initial state dictionary to ensure all fields are considered.
        initial_state_dict = {
            "target_request": target_request,
            "vulnerability_type": vulnerability_type,
            "target_parameter": target_parameter,
            "max_total_attempts": max_total_attempts,
            "target_parameter_baseline_value": None,
            "current_attack_strategy_summary": None,
            "current_payload_batch": [], 
            "current_payload_batch_index": 0,
            "current_payload": None,
            "current_llm_payload_strategy": None,
            "baseline_response": None, 
            "current_response": None,  
            "detailed_attempt_history": [], 
            "overall_attempt_count": 0,
            "individual_execution_count": 0,
            "consecutive_no_progress_attempts": 0,
            "max_consecutive_no_progress_per_strategy": 3, 
            "vulnerabilities_found": [], 
            "final_report": None,
            "stop_reason": None,
            "executive_summary_verdict": None,
            "executive_summary_reasoning": None,
            "confidence_threshold_vulnerable": 0.85 
        }
        initial_state_obj = PentestState(**initial_state_dict)
        
        if not hasattr(initial_state_obj, 'baseline_response'):
            print("CRITICAL ERROR: initial_state_obj does NOT have 'baseline_response' even after explicit dict init!")
        else:
            print(f"DEBUG: initial_state_obj.baseline_response exists. Value: {initial_state_obj.baseline_response}")

        print(f"\n🔥🔥🔥 Starting Dynamic Automated Pentest (Enhanced Strategies) 🔥🔥🔥")
        print(f"Target: '{target_request.name or target_request.url}' ({target_request.method})")
        print(f"Vulnerability: {vulnerability_type.value}, Parameter: '{target_parameter}'")
        print(f"Max Strategy/Batch Attempts: {max_total_attempts}")
        print("=" * 50)

        final_output_from_graph = await self.graph.ainvoke(initial_state_obj, {"recursion_limit": 250})
        
        final_state_obj: PentestState
        if isinstance(final_output_from_graph, PentestState):
            print("DEBUG: Graph returned a PentestState object directly.")
            final_state_obj = final_output_from_graph
            if not hasattr(final_state_obj, 'baseline_response'):
                 print("DEBUG ALERT: The PentestState object returned directly from graph is missing 'baseline_response'!")
            # else: # No need to print this every time if it works
                 # print(f"DEBUG: The PentestState object from graph has 'baseline_response', value: {final_state_obj.baseline_response}")

        elif isinstance(final_output_from_graph, dict):
            print("DEBUG: Graph returned a dict, attempting robust reconstruction...")
            graph_dict = final_output_from_graph.copy() 
            # print("DEBUG: Dictionary received from graph for reconstruction:")
            # pprint.pprint(graph_dict) # Can be very verbose, enable if needed

            critical_optional_fields = {
                'baseline_response': None, 'current_response': None,
                'target_parameter_baseline_value': None, 'current_attack_strategy_summary': None,
                'current_payload': None, 'current_llm_payload_strategy': None, 'final_report': None,
                'stop_reason': None, 'executive_summary_verdict': None, 'executive_summary_reasoning': None
            }
            for field_name, default_value in critical_optional_fields.items():
                if field_name not in graph_dict:
                    graph_dict[field_name] = default_value
            
            list_fields_with_default_factory = [
                'current_payload_batch', 'detailed_attempt_history', 'vulnerabilities_found'
            ]
            for field_name in list_fields_with_default_factory:
                if field_name not in graph_dict:
                    graph_dict[field_name] = []

            try:
                temp_state_obj = PentestState(**graph_dict)
                # print("DEBUG: Successfully created temp_state_obj from graph_dict.") # Verbose

                # if not hasattr(temp_state_obj, 'baseline_response'): # Should be fixed now
                #     print("CRITICAL DEBUG: temp_state_obj (from PentestState(**graph_dict)) is MISSING 'baseline_response' attribute!")
                # else:
                #     print(f"DEBUG: temp_state_obj has 'baseline_response', value: {temp_state_obj.baseline_response}")


                if isinstance(temp_state_obj.vulnerability_type, str):
                    temp_state_obj.vulnerability_type = VulnerabilityType(temp_state_obj.vulnerability_type)
                
                if isinstance(temp_state_obj.target_request, dict):
                     temp_state_obj.target_request = HttpRequest(**temp_state_obj.target_request) # type: ignore
                
                if temp_state_obj.baseline_response and isinstance(temp_state_obj.baseline_response, dict):
                    temp_state_obj.baseline_response = HttpResponse(**temp_state_obj.baseline_response) # type: ignore
                
                if temp_state_obj.current_response and isinstance(temp_state_obj.current_response, dict):
                    temp_state_obj.current_response = HttpResponse(**temp_state_obj.current_response) # type: ignore

                if isinstance(temp_state_obj.detailed_attempt_history, list):
                    rebuilt_history = []
                    for attempt_item in temp_state_obj.detailed_attempt_history:
                        if isinstance(attempt_item, dict):
                            attempt_dict_copy = dict(attempt_item)
                            if 'analysis_verdict' in attempt_dict_copy and isinstance(attempt_dict_copy['analysis_verdict'], str):
                                try:
                                    attempt_dict_copy['analysis_verdict'] = AnalysisVerdict(attempt_dict_copy['analysis_verdict'])
                                except ValueError:
                                    # print(f"Warning: Unknown analysis_verdict string '{attempt_dict_copy['analysis_verdict']}' in history. Defaulting to UNCERTAIN.")
                                    attempt_dict_copy['analysis_verdict'] = AnalysisVerdict.UNCERTAIN
                            rebuilt_history.append(AttemptDetail(**attempt_dict_copy))
                        elif isinstance(attempt_item, AttemptDetail): 
                            rebuilt_history.append(attempt_item)
                    temp_state_obj.detailed_attempt_history = rebuilt_history
                
                final_state_obj = temp_state_obj

            except Exception as e:
                print(f"ERROR: Critical failure during PentestState reconstruction from dict: {e}")
                print(f"DEBUG: Failing dictionary (graph_dict) that was passed to PentestState(**graph_dict) was:")
                pprint.pprint(graph_dict)
                final_state_obj = initial_state_obj 
                final_state_obj.stop_reason = (final_state_obj.stop_reason or "") + f" | CRITICAL: State reconstruction error from dict: {e}"
        else: 
            final_state_obj = initial_state_obj 
            final_state_obj.stop_reason = (final_state_obj.stop_reason or "") + " | CRITICAL: Unexpected graph output type."

        print("=" * 50)
        print("🏁🏁🏁 Dynamic Pentest (Enhanced Strategies) Completed! 🏁🏁🏁")
        return final_state_obj